// courtesy https://www.shadertoy.com/view/Wf3SWn
/*
    "Sunset" by @XorDev
    
    Expanded and clarified version of my Sunset shader:
    https://www.shadertoy.com/view/wXjSRt
    
    Based on my tweet shader:
    https://x.com/XorDev/status/1918764164153049480
*/
#ifdef GL_ES
precision mediump float;
#endif

#define BRIGHTNESS 1.0
#define COLOR_BASE 1.5
#define COLOR_SPEED 0.5
#define RGB vec3(0.0, 1.0, 2.0)
#define COLOR_WAVE 14.0
#define COLOR_DOT vec3(1.0, -1.0, 0.0)
#define WAVE_STEPS 8
const float WAVE_FREQ = 5.0;
const float WAVE_AMP = 0.6;
const float WAVE_EXP = 1.8;
const float WAVE_VELOCITY = 0.2;
const float PASSTHROUGH = 0.2;
const float SOFTNESS = 0.005;
const int STEPS = 100;
const float SKY = 10.0;
const float FOV = 1.0;

// Approximate tanh for WebGL 1.0
float tanh(float x) {
    float e2x = exp(2.0 * x);
    return (e2x - 1.0) / (e2x + 1.0);
}

vec3 tanh(vec3 x) {
    return (exp(2.0 * x) - 1.0) / (exp(2.0 * x) + 1.0);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float z = 0.0;
    float d = 0.0;
    float s = 0.0;

    vec3 dir = normalize(vec3(2.0 * fragCoord - iResolution.xy, -FOV * iResolution.y));
    vec3 col = vec3(0.0);

    for(int i = 0; i < STEPS; i++)
    {
        vec3 p = z * dir;

        // Turbulence loop
        float f = WAVE_FREQ;
        for(int j = 0; j < WAVE_STEPS; j++)
        {
            p += WAVE_AMP * sin(p * f - WAVE_VELOCITY * iTime).yzx / f;
            f *= WAVE_EXP;
        }

        s = 0.3 - abs(p.y);
        d = SOFTNESS + max(s, -s * PASSTHROUGH) / 4.0;
        z += d;

        float phase = COLOR_WAVE * s + dot(p, COLOR_DOT) + COLOR_SPEED * iTime;
        col += (cos(phase - RGB) + COLOR_BASE) * exp(s * SKY) / d;
    }

    col *= SOFTNESS / float(STEPS) * BRIGHTNESS;
    col = tanh(col * col);
    fragColor = vec4(col, 1.0);
}
